"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[187],{7187:function(e,t,a){a.r(t),a.d(t,{SiteContext:function(){return r},default:function(){return u}});var n=a(7437),s=a(2265);let r=(0,s.createContext)(),{NAV:i,TOGGLE:o,COLOR:l,POPUP:c,DIRECTION:d,DARK:h}={NAV:"NAV",TOGGLE:"TOGGLE",COLOR:"COLOR",DIRECTION:"DIRECTION",POPUP:"POPUP",DARK:"DARK"},m={nav:"home",toggle:!1,color:"yellow",direction:"right",popup:null,blogs:[{id:1,author:"Petr Penicka",date:"8 January 2025",tags:"React, TypeScript, jQuery, refactoring, modernization",title:"Lessons from The Past: Modernizing a Pre-React jQuery Codebase",img:"/assets/img/blog/frontend-evolution.png",desc:"In this blog post, I share my experience modernizing an old jQuery codebase—from removing jQuery and adopting TypeScript to refactoring incrementally for maintainability.",contentComponent:()=>{let{dark:e,changeNav:t}=(0,s.useContext)(r);return(0,n.jsxs)("div",{className:"font-Open-sans mb-60",children:[(0,n.jsx)("p",{className:"mb-28",children:"When I first got into frontend development in 2020, frameworks like React, Vue.js, and Angular were already widely adopted as the de-facto standard. My experience therefore revolved around component-based architecture, modular code organization, and virtual DOM rendering. jQuery and raw DOM manipulation were more of a history lesson than an everyday practice."}),(0,n.jsx)("p",{className:"mb-28",children:"At the same time, when talking to more senior engineers throughout my initial years, it became obvious that their experience in the pre-framework era is one of the key differentiators that gives them a deeper understanding of the subject, making them better engineers as a result. So, when a client approached me to modernize an older codebase built primarily with jQuery and vanilla JavaScript utilizing the DOM API, I immediately saw a unique opportunity—not only to help them upgrade but also to fill the gaps in my own understanding of how frontend was done before the frameworks took over."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"1. Understanding the Challenge"}),(0,n.jsx)("p",{className:"mb-28",children:"Modernizing an old codebase can mean various things:"}),(0,n.jsxs)("ul",{className:"list-in-blog mb-28 list-disc my-6 pl-6 text-gray-700 dark:text-gray-300",children:[(0,n.jsx)("li",{className:"mb-8",children:"Migrating from jQuery-dependent scripts to a modern library or framework."}),(0,n.jsx)("li",{className:"mb-8",children:"Refactoring scattered DOM manipulation into more structured, component-like patterns."}),(0,n.jsx)("li",{className:"mb-8",children:"Introducing build tools, linting, testing, and other modern development practices."})]}),(0,n.jsx)("p",{className:"mb-28",children:"But before deciding on any path forward, I needed to fully grasp what was already in place. The code I encountered was developed in an era where lengthy JavaScript files—often several hundreds of lines long—handled every aspect of client-side interaction, from AJAX calls to DOM manipulation. jQuery was the backbone of this setup, powering everything from event handling to animations. While this approach can still work for smaller sites, it quickly becomes unwieldy on larger or more complex projects. This particular codebase suffered from that exact challenge."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"2. Diving into Legacy Code"}),(0,n.jsx)("p",{className:"mb-28",children:"Whenever I start on a new project, my go-to move is to open the code in my editor, examine the file structure, and look for clues about the overall organization. This time, I immediately noticed how all the JavaScript was crammed into a few large files—each overflowing with jQuery calls and direct DOM manipulations that seemed to handle every aspect of the UI. It was a stark contrast to the modular, component-driven patterns I’m used to seeing in modern React or Vue.js projects."}),(0,n.jsx)("p",{className:"mb-28",children:"Digging deeper, I discovered a few key observations:"}),(0,n.jsxs)("ul",{className:"list-in-blog mb-28 list-disc list-inside my-6 pl-6 text-gray-700 dark:text-gray-300",children:[(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Event Handling:"})," Pre-React workflows typically rely on direct DOM event listeners or jQuery’s ",(0,n.jsx)("code",{children:".on()"})," methods. Modern React apps, on the other hand, tuck these inside components, sometimes using hooks or prop drilling."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"DOM Manipulation:"})," Without a virtual DOM or a state-driven rendering approach, the code frequently queried and updated the DOM in real time. It was a potent reminder of just how much work we offload to modern frameworks nowadays."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Spaghetti Code:"})," Because there wasn’t a clear separation of concerns, the HTML structure, styling hooks, and business logic often intermingled. Identifiers reappeared throughout, making it challenging to see how a single change might affect other parts of the application."]})]}),(0,n.jsx)("p",{className:"mb-28",children:"While this legacy approach felt quite cumbersome compared to contemporary best practices, it also highlighted exactly why frameworks like React gained such widespread popularity: they address the very pain points I saw in this codebase. Manual DOM queries, scattered event bindings, and tightly coupled business logic and presentation all underscored the necessity for a more structured and declarative approach. By experiencing firsthand how things were done before, I came away with a deeper appreciation for how component-based architectures streamline maintenance, reduce complexity, and pave the way for future scalability."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"3. Planning the Modernization"}),(0,n.jsx)("p",{className:"mb-28",children:"One of my first decisions was to remove jQuery entirely. Although it served a purpose back in the day—particularly for DOM queries, event handling, and AJAX calls—modern browsers now handle these tasks natively without any additional library overhead. By doing away with jQuery, we eliminated an unnecessary dependency, streamlined the codebase, and could rely on a single, consistent set of modern APIs moving forward."}),(0,n.jsx)("p",{className:"mb-28",children:"Here’s how I approached the planning phase:"}),(0,n.jsxs)("ul",{className:"list-in-blog mb-28 list-decimal pl-6 my-6 text-gray-700 dark:text-gray-300",children:[(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Assess the Business Requirements:"})," I first needed to confirm which aspects of the application were mission-critical, ensuring I didn’t accidentally break core functionality during the refactoring process."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Decide on a Framework (or Not):"})," While I ultimately chose React for new feature development and scalable UI architecture, I also recognized that many of the existing jQuery calls could be replaced with pure DOM methods (e.g.,",(0,n.jsx)("code",{children:"document.querySelector"}),", ",(0,n.jsx)("code",{children:"fetch"}),") for smaller, utility-level interactions."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Identify Modular Boundaries:"})," To keep the refactoring organized, I identified logical sections of the UI that could become self-contained. Some areas were better suited for a full React component refactor, while others only needed quick DOM manipulation."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Adopt a Gradual Transition:"})," Rather than tackle everything at once, I migrated features incrementally—swapping out jQuery for native DOM calls in smaller pieces, and introducing React components where it made sense. This approach let me validate each change before moving on to the next, reducing the likelihood of introducing new bugs."]})]}),(0,n.jsx)("p",{className:"mb-28",children:"By removing jQuery and relying on modern APIs, I set the stage for a cleaner, more maintainable codebase that’s easier to extend—be it with React or any other technology the project might need in the future."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"4. The Refactoring Process"}),(0,n.jsx)("p",{className:"mb-28",children:"I’m not a fan of an all-or-nothing “big bang” approach, which often creates more risks and complexities than necessary. Instead, I modernized the codebase step by step:"}),(0,n.jsxs)("ul",{className:"list-in-blog mb-28 list-decimal pl-6 my-6 text-gray-700 dark:text-gray-300",children:[(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Replace jQuery with Native DOM APIs:"})," Wherever jQuery calls existed, I swapped them out for direct DOM queries (e.g.,"," ",(0,n.jsx)("code",{children:"document.querySelector"}),") and the",(0,n.jsx)("code",{children:"fetch"})," API. This helped break the project’s reliance on an outdated library, making the code leaner and easier to maintain."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Adopt TypeScript for Strong Typing:"})," To boost reliability and catch potential errors earlier, I introduced TypeScript. I began gradually converting key JavaScript files to TypeScript, focusing on critical modules first. This allowed for better type checking, improved editor support, and more predictable refactoring as the project grew."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Consolidate Redundant Logic:"})," One challenge in legacy code is scattered, duplicated functions or utilities. I identified common patterns and merged them into centralized helper modules, which simplified maintenance and improved overall consistency. By establishing naming conventions along the way, the code became much more navigable for future changes."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Incremental UI Updates:"})," I tackled UI adjustments in small chunks—either with minimal native DOM manipulation where needed or by gradually bringing in modern practices, such as lightweight React components if suitable. This approach enabled me to verify each enhancement thoroughly before proceeding, maintaining a stable codebase throughout the refactoring process."]})]}),(0,n.jsx)("p",{className:"mb-28",children:"By proceeding iteratively, I was able to confirm functionality at each step, mitigating the risk of major regressions and ensuring that each improvement built upon a solid foundation."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"5. Key Lessons Learned"}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"5.1 Respect for Legacy Approaches"}),(0,n.jsx)("p",{className:"mb-28",children:"Working with a jQuery-centric codebase was a humbling reminder of just how much manual effort goes into event handling, DOM manipulation, and maintaining UI state. It gave me a renewed appreciation for the developers who honed these skills before modern frameworks became the norm."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"5.2 Benefits of Modern Frameworks"}),(0,n.jsx)("p",{className:"mb-28",children:"Manually tracking UI state can be cumbersome, and that’s precisely where frameworks like React shine. State-driven rendering, modular components, and clear data flow patterns help large applications remain both organized and maintainable."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"5.3 Incremental Refactoring is Your Friend"}),(0,n.jsx)("p",{className:"mb-28",children:"Refactoring doesn’t have to be stressful or all-encompassing. By approaching it in small steps, you can stabilize each section of the application before proceeding, minimizing the risk of introducing new bugs or disrupting core functionality."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"5.4 Code Consistency & Readability"}),(0,n.jsx)("p",{className:"mb-28",children:"In the process of stripping out jQuery and organizing the code, I discovered numerous small opportunities to standardize function names, reduce duplication, and make logic more transparent. These incremental improvements not only enhanced readability but also made the project easier to navigate for future maintainers."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"6. Conclusion"}),(0,n.jsx)("p",{className:"mb-28",children:"Refactoring a jQuery-era application into a modern React-based stack has been a journey through both past and present. While React and Vue.js dominate the conversation these days, I discovered there’s real value in understanding the manual DOM manipulation and event management patterns that came before. This broader perspective not only makes me a more adaptable engineer but also enhances my ability to troubleshoot complex legacy issues."}),(0,n.jsx)("p",{className:"mb-28",children:"For the client, the end result was a faster, more maintainable application—one that’s set up for smoother upgrades and future growth. For me, it was a chance to deepen my technical knowledge and sharpen my refactoring skills. As the industry continues to evolve, having a foot in both the old and new worlds helps me bridge the gap for clients who need to modernize without losing the core of what their applications were built to do."}),(0,n.jsxs)("p",{className:"mb-28",children:["If you’d like to learn more about my experience with software modernization, frontend engineering best practices, or how I approach refactoring, feel free to"," ",(0,n.jsx)("a",{className:"font-bold",onClick:()=>t("contact"),children:"reach out"})," ","or explore my \xa0",(0,n.jsx)("a",{className:"font-bold",onClick:()=>t("portfolio"),children:"portfolio"}),". I’m always open to connecting, sharing knowledge, and hearing about new challenges in the ever-changing landscape of web development."]})]})}},{id:2,author:"Petr Penicka",date:"5 February 2025",tags:"React, Vue.js, Next.js, Nuxt.js",title:"A Foot in Both Camps: My Experience With React and Vue.js",img:"/assets/img/blog/react-vue.png",desc:"Ever wondered how developers switch between React and Vue.js? In this article, I share my journey across both frameworks, showing that once you’ve mastered the fundamentals in one, you’re already halfway to mastering the other.",contentComponent:()=>{let{dark:e,changeNav:t}=(0,s.useContext)(r);return(0,n.jsxs)("div",{className:"font-Open-sans mb-60",children:[(0,n.jsxs)("p",{className:"mb-28",children:["When I first stepped into the world of frontend engineering, React was the hot technology everyone was talking about and migrating to. As someone new to the frontend game, I adopted it as a foundational part of my stack, immersing myself in virtual DOM rendering, JSX syntax, and unidirectional data flows. As my career progressed, however, changing employers introduced me to",(0,n.jsx)("strong",{children:" Vue.js "})," and its server-side sibling,"," ",(0,n.jsx)("strong",{children:" Nuxt.js "}),"— where I discovered a similar yet distinctly flavored way of building component-based UIs. Today, I often switch between React, Vue.js, and modern SSR solutions like"," ",(0,n.jsx)("strong",{children:" Next.js "})," and ",(0,n.jsx)("strong",{children:" Nuxt.js "}),". Through this cross-framework journey, I’ve come to realize that React and Vue.js share far more common ground than many people assume: once you grasp the fundamentals in one, you’re already halfway to mastering the other."]}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"1. My Personal Timeline"}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"First Year: ManoMano with React"}),(0,n.jsxs)("p",{className:"mb-28",children:["I launched my engineering career at ManoMano, where React reigned supreme. From day one, I was immersed in JSX, functional components, and unidirectional data flow patterns—alongside community-driven solutions like",(0,n.jsx)("strong",{children:" React Router "})," for routing and ",(0,n.jsx)("strong",{children:" Redux "})," ","for state management. Because this was my first professional engineering role, I assumed these techniques were simply how modern frontend development was done. Looking back, I’m grateful that my first employer adopted such a cutting-edge stack; it meant I got to learn best practices from the very start."]}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"Second to Fourth Year: Glovo with Vue.js and Nuxt.js"}),(0,n.jsxs)("p",{className:"mb-28",children:["After a year at ManoMano, an unexpected email from Glovo landed in my inbox—a compelling offer I couldn’t refuse. The only catch was the need to become proficient with ",(0,n.jsx)("strong",{children:" Vue.js "})," shortly after joining. I saw it as a unique opportunity and embraced the challenge. Initially, single-file components in ",(0,n.jsx)("code",{children:".vue"})," felt unfamiliar, but I quickly recognized the same core principles of component hierarchy, reactivity, and modular design. Within a week, I was writing my first components confidently; a couple of weeks later, I’d reached the same productivity level I had with React. This was a pivotal “aha” moment, showing me that differences between frontend technologies aren’t as drastic as they might appear and that strong fundamentals enable rapid switching."]}),(0,n.jsxs)("p",{className:"mb-28",children:["Toward the end of my time at Glovo, I led a project to migrate a courier onboarding website from WordPress to a modern ",(0,n.jsx)("strong",{children:" Nuxt.js "}),"-based stack with static site rendering and Prismic CMS integration. This experience underscored how frameworks like Nuxt.js (and by extension Next.js) streamline the development of even relatively simple websites."]}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"Fifth Year: Slash.digital, Pura Design, and Switching Between Vue.js, React, Nuxt.js, and Next.js"}),(0,n.jsxs)("p",{className:"mb-28",children:["Currently, I juggle multiple projects: ",(0,n.jsx)("strong",{children:" Vue.js/Nuxt.js "})," ","at Slash.digital, ",(0,n.jsx)("strong",{children:" React/Next.js "})," at Pura Design, and this very portfolio site (plus other personal projects) in"," ",(0,n.jsx)("strong",{children:" Next.js "}),". Although it might sound hectic, switching between React and Vue.js is surprisingly straightforward once you understand their shared principles around state management, lifecycle hooks, and component-driven UIs. Thanks to these similarities, I experience minimal friction when context-switching, allowing me to serve my clients’ needs—no matter which framework they prefer."]}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"2. Similarities Between React and Vue.js"}),(0,n.jsx)("p",{className:"mb-28",children:"Despite having distinct syntaxes and tooling, React and Vue.js share a foundation that makes it easy to jump from one to the other:"}),(0,n.jsxs)("ul",{className:"list-in-blog mb-28 list-decimal pl-6 my-6 text-gray-700 dark:text-gray-300",children:[(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Virtual DOM & Reactive Rendering"}),(0,n.jsx)("br",{}),"Both frameworks use a virtual DOM to track changes to the application’s state, only re-rendering the parts that actually change.",(0,n.jsxs)("ul",{className:"list-disc list-inside ml-6 my-2",children:[(0,n.jsxs)("li",{children:[(0,n.jsx)("strong",{children:"React:"})," Relies on state or prop updates to trigger re-renders."]}),(0,n.jsxs)("li",{children:[(0,n.jsx)("strong",{children:"Vue.js:"})," Uses a more granular reactivity system, but the outcome—“change data, update UI”—remains the same."]})]})]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Component-Centric Architecture"}),(0,n.jsx)("br",{}),"Both React and Vue.js emphasize small, reusable components to manage state, handle logic, and render UIs.",(0,n.jsxs)("ul",{className:"list-disc list-inside ml-6 my-2",children:[(0,n.jsxs)("li",{children:[(0,n.jsx)("strong",{children:"React:"})," Integrates markup with logic via JSX (or TSX)."]}),(0,n.jsxs)("li",{children:[(0,n.jsx)("strong",{children:"Vue.js:"})," Single-file components break out templates, scripts, and styles, but the fundamentals—“props in, events out”— mirror React’s approach."]})]})]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Robust Ecosystems"}),(0,n.jsx)("br",{}),"No matter which framework you pick, you’ll find well-established, well-documented tools for routing, state management, testing, and server-side rendering.",(0,n.jsxs)("ul",{className:"list-disc list-inside ml-6 my-2",children:[(0,n.jsxs)("li",{children:[(0,n.jsx)("strong",{children:"React:"})," React Router, Redux, Jest, Next.js."]}),(0,n.jsxs)("li",{children:[(0,n.jsx)("strong",{children:"Vue.js:"})," Vue Router, Vuex (or Pinia), Vitest/Jest, Nuxt.js."]})]})]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Modern Toolchains"}),(0,n.jsx)("br",{}),"Both frameworks integrate seamlessly with bundlers, build tools, and TypeScript. React offers Create React App or Next.js; Vue.js offers the Vue CLI or Nuxt.js. This keeps setup time short and paves the way for hot reloading, ES modules, and code splitting."]})]}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"3. Diving Deeper: Differences in Syntax and Approach"}),(0,n.jsx)("p",{className:"mb-28",children:"Even with their shared philosophies, React and Vue.js take distinct paths on a few details:"}),(0,n.jsxs)("ul",{className:"list-in-blog mb-28 list-decimal pl-6 my-6 text-gray-700 dark:text-gray-300",children:[(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Templating vs. JSX"}),(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"React:"})," Embraces JSX, blending HTML-like syntax with JavaScript for maximum flexibility.",(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"Vue.js:"})," Primarily uses templates with directives like",(0,n.jsx)("code",{className:"mx-1",children:"v-if"}),",",(0,n.jsx)("code",{className:"mx-1",children:"v-for"}),", and",(0,n.jsx)("code",{className:"mx-1",children:"v-bind"}),". While the Composition API supports a JSX approach, templates remain the default."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Reactivity Models"}),(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"React:"})," Hooks like",(0,n.jsx)("code",{className:"mx-1",children:"useState"})," and",(0,n.jsx)("code",{className:"mx-1",children:"useEffect"})," manage local state and side effects, re-rendering the entire component on state change.",(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"Vue.js:"})," Monitors reactive data at a granular level, re-rendering only the affected components. The Composition API (",(0,n.jsx)("code",{className:"mx-1",children:"setup"}),") may look like React hooks, but reactivity is still built into Vue’s core."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"State Management"}),(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"React:"})," Often relies on external libraries—Redux, Recoil, or MobX—for global state.",(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"Vue.js:"})," Tends to use Vuex or Pinia, which integrate closely with the core framework. Both share the principle of a single source of truth for data across components."]}),(0,n.jsxs)("li",{className:"mb-8",children:[(0,n.jsx)("strong",{children:"Opinionated vs. Unopinionated"}),(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"React:"})," Encourages you to build your own conventions or adopt community-driven standards.",(0,n.jsx)("br",{}),(0,n.jsx)("strong",{children:"Vue.js:"})," Provides official solutions (Vuex, Vue Router) and, via Nuxt.js, offers an opinionated structure for file organization and server-side rendering."]})]}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"4. Lessons Learned in My Cross-Framework Journey"}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"4.1 Master the Basics"}),(0,n.jsx)("p",{className:"mb-28",children:"Regardless of framework, the essential skills—HTML, CSS, JavaScript, and a solid grasp of core web APIs—make transitioning between React and Vue.js far less intimidating. Strong fundamentals are what truly matter."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"4.2 Embrace SSR Solutions"}),(0,n.jsxs)("p",{className:"mb-28",children:[(0,n.jsx)("strong",{children:"Nuxt.js"})," for Vue.js and ",(0,n.jsx)("strong",{children:"Next.js"})," for React both streamline server-side rendering. They solve similar problems: improved SEO, faster initial loads, and structured data-fetching approaches. Knowing one makes learning the other straightforward."]}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"4.3 Adapt Patterns, Don’t Reinvent Them"}),(0,n.jsx)("p",{className:"mb-28",children:"React developers may lean on Redux or Context, while Vue.js developers often use Vuex or Pinia. The names change, but the principle—managing global state efficiently—remains the same. Embrace that mental model, and the syntax switch becomes trivial."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"4.4 Explore Official and Community Tools"}),(0,n.jsx)("p",{className:"mb-28",children:"Vue.js’s core team maintains Vue Router and Vuex, while React’s equivalents tend to be community-driven (e.g., Redux, React Router). Both ecosystems are robust; experimenting with different solutions reinforces your understanding of how each framework operates."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"5. Where I Am Now"}),(0,n.jsxs)("p",{className:"mb-28",children:["Between my roles at Slash.digital (",(0,n.jsx)("strong",{children:"Vue.js/Nuxt.js"}),") and Pura Design (React), alongside building this blog in"," ",(0,n.jsx)("strong",{children:"Next.js"}),", I’ve discovered the flexibility that comes from working with multiple frameworks. Once you’ve spent significant time with both, toggling between them is more about small syntax differences than re-learning architectural principles. These cross-framework insights also reveal patterns—like how SSR simplifies SEO or how centralized stores reduce prop-drilling—regardless of which ecosystem you use."]}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"6. Conclusion"}),(0,n.jsx)("p",{className:"mb-28",children:"Having spent time with React at ManoMano, Vue.js at Glovo, and now Nuxt.js and Next.js in my later years, I’m convinced React and Vue.js are more alike than different. Their core philosophies—component-driven design, reactive rendering, and an active ecosystem—remain consistent. Syntax is merely the wrapping paper."}),(0,n.jsx)("p",{className:"mb-28",children:"If you’ve mastered one of these frameworks, you have a significant head start in learning the other. The real skills—structuring your app, managing state effectively, and building maintainable components—apply across both ecosystems. That’s what makes modern frontend development so exciting: once you learn the patterns, you can pick up new tools without starting from scratch."}),(0,n.jsxs)("p",{className:"mb-28",children:["Curious about more of my experiences switching between Vue.js and React? Feel free to"," ",(0,n.jsx)("a",{className:"font-bold",onClick:()=>t("contact"),children:"drop me a message"})," ","or explore my"," ",(0,n.jsx)("a",{className:"font-bold",onClick:()=>t("portfolio"),children:"portfolio"}),". I’m always up for discussing how these frameworks overlap, diverge, and ultimately shape our ever-evolving landscape of web development."]})]})}},{id:3,author:"Petr Penicka",date:"13 February 2025",tags:"freelance, remote work, productivity, work-life balance",title:"One Year of Freelancing: Lessons in Flexibility, Growth and Independence",img:"/assets/img/blog/home-office.png",desc:"A year into freelancing, I’ve unlocked new skills, greater flexibility, and a whole new way of thinking. Here’s what I’ve learned outside the world of 9-to-5.",contentComponent:()=>{let{dark:e,changeNav:t}=(0,s.useContext)(r);return(0,n.jsxs)("div",{className:"font-Open-sans mb-60",children:[(0,n.jsx)("p",{className:"mb-28",children:"When I transitioned to freelancing nearly a year ago, I was excited about the possibilities but also aware of the uncertainties. Would I be able to consistently find projects? Would I enjoy working independently as much as I imagined? Could I continue growing professionally without the structured career paths of a traditional company?"}),(0,n.jsx)("p",{className:"mb-28",children:"Now, as I reflect on my first year as a freelancer, I realize just how much I’ve learned—not just about managing projects and clients, but about adaptability, personal growth, and the evolving nature of work itself. The experience has given me a fresh perspective on my career and equipped me with valuable skills that apply to any professional setting, whether independent or within an organization."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"1. Adapting to Different Work Styles"}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"1.1 Navigating Diverse Client Expectations"}),(0,n.jsx)("p",{className:"mb-28",children:"One of the most valuable skills I’ve gained as a freelancer is the ability to quickly adapt to different work styles. Every client operates differently—some prefer detailed documentation and structured workflows, while others favor a more agile, fast-paced approach. Learning to navigate these varying expectations has strengthened my ability to communicate clearly, manage priorities effectively, and integrate seamlessly into different teams and project structures."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"1.2 Managing Time and Productivity"}),(0,n.jsx)("p",{className:"mb-28",children:"Without the structure of a traditional office environment, I had to develop strong time management habits and self-discipline. I experimented with different productivity techniques, from time blocking to prioritization frameworks, to ensure I stayed on track without micromanagement or rigid schedules."}),(0,n.jsx)("p",{className:"mb-28",children:"This experience reinforced an important lesson: productivity isn’t about working longer hours but about structuring time effectively. Whether in a freelance or corporate setting, the ability to manage tasks efficiently, balance multiple projects, and maintain focus is key to long-term success."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"2. Broadening My Technical Skill Set"}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"2.1 Exposure to a Variety of Technologies"}),(0,n.jsx)("p",{className:"mb-28",children:"One of the aspects I’ve enjoyed most about freelancing is the exposure to a diverse range of projects, codebases, and technologies. Since I’m not tied to a single product or tech stack, I’ve had the opportunity to work on both greenfield projects and legacy modernization, switching between frameworks like Vue.js, React, and Next.js depending on the project’s needs."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"2.2 Keeping Up with Emerging Trends"}),(0,n.jsx)("p",{className:"mb-28",children:"With the rapid evolution of AI and modern development practices, staying up to date is more important than ever. Freelancing has allowed me to explore new technologies as they emerge, whether integrating AI-driven solutions, experimenting with fresh methodologies, or optimizing workflows with automation."}),(0,n.jsx)("p",{className:"mb-28",children:"Unlike in structured organizations, where technology adoption often follows a set roadmap, freelancing gives me the flexibility to set up my own processes and immediately implement new tools that enhance productivity and efficiency. This level of autonomy has encouraged me to be more proactive in research and innovation, a habit that I believe is just as valuable in any team environment where staying ahead of industry trends is a priority."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"3. Learning to Manage Uncertainty"}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"3.1 Handling Financial Variability"}),(0,n.jsx)("p",{className:"mb-28",children:"Unlike a salaried position, freelance income can fluctuate, which initially felt like a challenge. Fortunately, I started out with a high-workload client, and by my third month, I had already tripled my previous monthly earnings—an eye-opening realization of freelancing’s potential. However, as that initial project came to an end, I faced the reality of securing new clients, a process that required persistence, networking, and strategic planning."}),(0,n.jsx)("h3",{className:"mt-8 mb-3 text-fs-21 font-bold text-gray-800 dark:text-gray-100",children:"3.2 Managing Multiple Projects and Priorities"}),(0,n.jsx)("p",{className:"mb-28",children:"Freelancing often involves juggling multiple clients and projects, each with its own timelines, requirements, and workflows. Learning to navigate these complexities has strengthened my ability to manage competing priorities, set clear expectations, and ensure deliverables are met on time."}),(0,n.jsx)("h2",{className:"mb-20 mt-35 text-fs-26 font-bold text-gray-800 dark:text-gray-100",children:"5. Closing Thoughts"}),(0,n.jsx)("p",{className:"mb-28",children:"After a year of freelancing, I’ve gained not only technical experience but also valuable lessons in adaptability, communication, and strategic thinking. This journey has reinforced the importance of continuous learning, taking ownership, and staying flexible in an ever-changing industry."}),(0,n.jsx)("p",{className:"mb-28",children:"Regardless of the work model, success ultimately comes down to problem-solving, collaboration, and delivering meaningful results. Looking ahead, I’m excited to keep growing, refining my skills, and embracing the opportunities that come next."}),(0,n.jsxs)("p",{className:"mb-28",children:["Curious to hear more about my journey or discuss opportunities? Feel free to"," ",(0,n.jsx)("a",{className:"font-bold cursor-pointer",onClick:()=>t("contact"),children:"reach out"})," ","or explore my"," ",(0,n.jsx)("a",{className:"font-bold cursor-pointer",onClick:()=>t("portfolio"),children:"portfolio"}),". I’m always open to connecting, sharing knowledge, and discussing the future of work in tech."]})]})}}],dark:!0},g=(e,t)=>{let{type:a,payload:n}=t;switch(a){case i:return{...e,nav:n};case o:return{...e,toggle:n};case l:return{...e,color:n};case d:return{...e,direction:n};case c:return{...e,popup:n};case h:return{...e,dark:n};default:return e}};var u=e=>{let{children:t}=e,[a,u]=(0,s.useReducer)(g,m),p=(0,s.useCallback)((e,t)=>{u({type:i,payload:e}),u({type:o,payload:t})},[]),f=(0,s.useCallback)(e=>{u({type:l,payload:e})},[]),y=(0,s.useCallback)(e=>{u({type:d,payload:e})},[]),x=(0,s.useCallback)(e=>{u({type:c,payload:e})},[]),b=(0,s.useCallback)(e=>{u({type:h,payload:e})},[]),{nav:j,toggle:w,color:v,direction:k,popup:N,blogs:I,dark:R}=a;return(0,n.jsx)(r.Provider,{value:{nav:j,changeNav:p,toggle:w,color:v,changeColor:f,direction:k,changeDirection:y,popupToggle:x,popup:N,blogs:I,dark:R,darkToggle:b},children:t})}}}]);